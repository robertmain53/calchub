import type { Locale, RouteName, RouteObject } from './types.js';
/**
 * Find the browser locale
 *
 * @param locales - The target {@link Locale} list
 * @param browserLocales - The locale code list that is used in browser
 *
 * @returns The matched the locale code
 * @internal
 */
export declare function findBrowserLocale(locales: Locale[], browserLocales: readonly string[]): string;
export declare function getRouteNameLocaleRegex(options: {
    localeCodes: string[];
    separator: string;
    defaultSuffix: string;
}, localesPattern?: string): RegExp;
/**
 * Convenience function to return the first match of the regex or empty string
 * @internal
 */
export declare function createNameLocaleRegexMatcher(re: RegExp): (val: string) => string;
/**
 * Normalizes {@link RouteName} to string
 * @internal
 */
export declare function normalizeRouteName(routeName: RouteName): string;
/**
 * Normalizes {@link RouteName} or {@link RouteObject} to string
 * @internal
 */
export declare function getRouteName(route: RouteName | RouteObject): string;
/**
 * Extract route name without localization from {@link RouteName} or {@link RouteObject}
 * @internal
 */
export declare function getRouteBaseName(route: RouteName | RouteObject, separator: string): string;
export declare function getLocalizedRouteName(routeName: string, locale: string, isDefault: boolean, separator?: string, defaultSuffix?: string): string;
/**
 * Match locale code from route path (e.g. `/en/about` => `en`)
 * @internal
 */
export declare function getRoutePathLocaleRegex(localeCodes: string[], localesPattern?: string): RegExp;
/**
 * NOTE: this likely needs to be implemented on the utility function consumer side
 * @internal
 */
export declare function createLocaleFromRouteGetter(options: {
    localeCodes: string[];
    separator: string;
    defaultSuffix: string;
}): (route: RouteName | RouteObject) => string;
