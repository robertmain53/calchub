import { isEqual, joinURL, withoutTrailingSlash, withTrailingSlash } from "ufo";
import { assign, isFunction, isString } from "@intlify/shared";
import { navigateTo, useNuxtApp, useRouter, useState } from "#imports";
import { localeCodes, localeLoaders, normalizedLocales, vueI18nConfigs } from "#build/i18n.options.mjs";
import { getComposer, getI18nTarget } from "./compatibility.js";
import { getHost, getLocaleDomain } from "./domain.js";
import { detectBrowserLanguage } from "./internal.js";
import { loadAndSetLocaleMessages, loadLocale, loadVueI18nOptions, makeFallbackLocaleCodes } from "./messages.js";
import { normalizeRouteName, getRouteBaseName as _getRouteBaseName, getLocalizedRouteName } from "#i18n-kit/routing";
import {
  localePath,
  switchLocalePath
} from "./routing/routing.js";
import { createLogger } from "#nuxt-i18n/logger";
import { unref } from "vue";
export function formatMessage(message) {
  return `[${__NUXT_I18N_MODULE_ID__}]: ${message}`;
}
export const isRouteLocationPathRaw = (val) => !!val.path && !val.name;
export function useComposableContext() {
  const context = useNuxtApp()._nuxtI18n;
  if (!context) {
    throw new Error(
      "i18n context is not initialized. Ensure the i18n plugin is installed and the composable is used within a Vue component or setup function."
    );
  }
  return context;
}
export function createComposableContext({
  i18n: _i18n,
  runtimeI18n,
  getDomainFromLocale
}) {
  const router = useRouter();
  const nuxt = useNuxtApp();
  const i18n = getI18nTarget(_i18n);
  const routeByPathResolver = createLocalizedRouteByPathResolver(router);
  const getLocalizedRouteName2 = createLocaleRouteNameGetter(runtimeI18n.defaultLocale);
  function getRouteBaseName(route) {
    return _getRouteBaseName(route, __ROUTE_NAME_SEPARATOR__);
  }
  function resolveLocalizedRouteByName(route, locale) {
    route.name ||= getRouteBaseName(router.currentRoute.value);
    const localizedName = getLocalizedRouteName2(route.name, locale);
    if (router.hasRoute(localizedName)) {
      route.name = localizedName;
    }
    return route;
  }
  function resolveLocalizedRouteByPath(input, locale) {
    const route = routeByPathResolver(input, locale);
    const baseName = getRouteBaseName(route);
    if (baseName) {
      route.name = getLocalizedRouteName2(baseName, locale);
      return route;
    }
    if (!__DIFFERENT_DOMAINS__ && prefixable(locale, runtimeI18n.defaultLocale)) {
      route.path = "/" + locale + route.path;
    }
    route.path = (__TRAILING_SLASH__ ? withTrailingSlash : withoutTrailingSlash)(route.path, true);
    return route;
  }
  return {
    router,
    getRoutingOptions: () => ({
      defaultLocale: runtimeI18n.defaultLocale,
      strictCanonicals: runtimeI18n.experimental.alternateLinkCanonicalQueries ?? true,
      hreflangLinks: !(__I18N_STRATEGY__ === "no_prefix" && !__DIFFERENT_DOMAINS__)
    }),
    getLocale: () => unref(i18n.locale),
    getLocales: () => {
      const locales = unref(i18n.locales);
      return locales.map((x) => isString(x) ? { code: x } : x);
    },
    getBaseUrl: () => joinURL(unref(i18n.baseUrl), nuxt.$config.app.baseURL),
    getRouteBaseName,
    getLocalizedDynamicParams: (locale) => {
      const params = router.currentRoute.value.meta[__DYNAMIC_PARAMS_KEY__] ?? {};
      return params[locale];
    },
    afterSwitchLocalePath: (path, locale) => {
      if (__DIFFERENT_DOMAINS__) {
        const domain = getDomainFromLocale(locale);
        return domain && joinURL(domain, path) || path;
      }
      return path;
    },
    resolveLocalizedRouteObject: (route, locale) => {
      return isRouteLocationPathRaw(route) ? resolveLocalizedRouteByPath(route, locale) : resolveLocalizedRouteByName(route, locale);
    }
  };
}
export async function loadAndSetLocale(newLocale, initial = false) {
  const logger = /* @__PURE__ */ createLogger("loadAndSetLocale");
  const nuxtApp = useNuxtApp();
  const runtimeI18n = nuxtApp.$config.public.i18n;
  const { skipSettingLocaleOnNavigate, detectBrowserLanguage: opts } = runtimeI18n;
  const oldLocale = unref(nuxtApp.$i18n.locale);
  const localeCodes2 = unref(nuxtApp.$i18n.localeCodes);
  function syncCookie(locale = oldLocale) {
    if (opts === false || !opts.useCookie) return;
    if (skipSettingLocaleOnNavigate) return;
    nuxtApp.$i18n.setLocaleCookie(locale);
  }
  const localeOverride = await nuxtApp.$i18n.onBeforeLanguageSwitch(oldLocale, newLocale, initial, nuxtApp);
  if (localeOverride && localeCodes2.includes(localeOverride)) {
    if (oldLocale === localeOverride) {
      syncCookie();
      return false;
    }
    newLocale = localeOverride;
  }
  __DEBUG__ && logger.log({ newLocale, oldLocale, initial });
  if (!newLocale) {
    syncCookie();
    return false;
  }
  if (!initial && __DIFFERENT_DOMAINS__) {
    syncCookie();
    return false;
  }
  if (oldLocale === newLocale) {
    syncCookie();
    return false;
  }
  const i18nFallbackLocales = unref(nuxtApp.$i18n.fallbackLocale);
  const setter = nuxtApp.$i18n.mergeLocaleMessage.bind(nuxtApp.$i18n);
  if (i18nFallbackLocales) {
    const fallbackLocales = makeFallbackLocaleCodes(i18nFallbackLocales, [newLocale]);
    await Promise.all(fallbackLocales.map((locale) => loadLocale(locale, localeLoaders, setter, nuxtApp)));
  }
  await loadLocale(newLocale, localeLoaders, setter, nuxtApp);
  if (skipSettingLocaleOnNavigate) {
    return false;
  }
  syncCookie(newLocale);
  nuxtApp._vueI18n.__setLocale(newLocale);
  await nuxtApp.$i18n.onLanguageSwitched(oldLocale, newLocale);
  return true;
}
export function detectLocale(route, routeLocale, currentLocale, localeCookie) {
  const nuxtApp = useNuxtApp();
  const runtimeI18n = nuxtApp.$config.public.i18n;
  const { defaultLocale, detectBrowserLanguage: _detect } = runtimeI18n;
  const logger = /* @__PURE__ */ createLogger("detectLocale");
  const detectedBrowser = detectBrowserLanguage(route, localeCookie, currentLocale);
  __DEBUG__ && logger.log({ detectBrowserLanguage: detectedBrowser });
  if (detectedBrowser.locale && detectedBrowser.from != null && localeCodes.includes(detectedBrowser.locale)) {
    return detectedBrowser.locale;
  }
  let detected = "";
  __DEBUG__ && logger.log("1/3", { detected, strategy: __I18N_STRATEGY__ });
  if (__DIFFERENT_DOMAINS__ || __MULTI_DOMAIN_LOCALES__) {
    detected ||= getLocaleDomain(normalizedLocales, route);
  } else if (__I18N_STRATEGY__ !== "no_prefix") {
    detected ||= routeLocale;
  }
  __DEBUG__ && logger.log("2/3", { detected, detectBrowserLanguage: _detect });
  const cookieLocale = (localeCodes.includes(detectedBrowser.locale) || localeCookie && localeCodes.includes(localeCookie)) && _detect && _detect.useCookie && localeCookie;
  detected ||= cookieLocale || currentLocale || defaultLocale || "";
  __DEBUG__ && logger.log("3/3", { detected, cookieLocale, defaultLocale, localeCookie });
  return detected;
}
export function detectRedirect({ to, from, locale, routeLocale }, inMiddleware = false) {
  if (routeLocale === locale || __I18N_STRATEGY__ === "no_prefix") {
    return "";
  }
  const logger = /* @__PURE__ */ createLogger("detectRedirect");
  __DEBUG__ && logger.log({ to, from });
  __DEBUG__ && logger.log({ locale, routeLocale, inMiddleware });
  const ctx = useComposableContext();
  let redirectPath = switchLocalePath(ctx, locale, to);
  if (inMiddleware && !redirectPath) {
    redirectPath = localePath(ctx, to.fullPath, locale);
  }
  if (isEqual(redirectPath, to.fullPath) || from && isEqual(redirectPath, from.fullPath)) {
    return "";
  }
  return redirectPath;
}
const useRedirectState = () => useState(__NUXT_I18N_MODULE_ID__ + ":redirect", () => "");
export async function navigate({ nuxt, locale, route, redirectPath }, enableNavigate = false) {
  const { rootRedirect, skipSettingLocaleOnNavigate, locales } = nuxt.$config.public.i18n;
  const logger = /* @__PURE__ */ createLogger("navigate");
  __DEBUG__ && logger.log("options", {
    rootRedirect,
    differentDomains: __DIFFERENT_DOMAINS__,
    skipSettingLocaleOnNavigate,
    enableNavigate,
    isSSG: __IS_SSG__
  });
  if (route.path === "/" && rootRedirect) {
    let redirectCode = 302;
    if (isString(rootRedirect)) {
      redirectPath = "/" + rootRedirect;
    } else {
      redirectPath = "/" + rootRedirect.path;
      redirectCode = rootRedirect.statusCode;
    }
    redirectPath = nuxt.$localePath(redirectPath, locale);
    __DEBUG__ && logger.log("rootRedirect mode", { redirectPath, redirectCode });
    return navigateTo(redirectPath, { redirectCode });
  }
  if (import.meta.client && skipSettingLocaleOnNavigate) {
    nuxt._vueI18n.__pendingLocale = locale;
    nuxt._vueI18n.__pendingLocalePromise = new Promise((resolve) => {
      nuxt._vueI18n.__resolvePendingLocalePromise = () => resolve();
    });
    if (!enableNavigate) {
      return;
    }
  }
  if (__MULTI_DOMAIN_LOCALES__ && __I18N_STRATEGY__ === "prefix_except_default") {
    const host = getHost();
    const currentDomain = locales.find((locale2) => {
      if (isString(locale2)) return;
      return locale2.defaultForDomains?.find((domain) => domain === host);
    });
    const defaultLocaleForDomain = !isString(currentDomain) ? currentDomain?.code : void 0;
    if (route.path.startsWith(`/${defaultLocaleForDomain}`)) {
      return navigateTo(route.path.replace(`/${defaultLocaleForDomain}`, ""));
    }
    if (!route.path.startsWith(`/${locale}`) && locale !== defaultLocaleForDomain) {
      const oldLocale = nuxt._vueI18n.__localeFromRoute(route.path);
      if (oldLocale !== "") {
        return navigateTo(`/${locale + route.path.replace(`/${oldLocale}`, "")}`);
      }
      return navigateTo(`/${locale + (route.path === "/" ? "" : route.path)}`);
    }
    if (redirectPath && route.path !== redirectPath) {
      return navigateTo(redirectPath);
    }
    return;
  }
  if (__DIFFERENT_DOMAINS__) {
    const state = useRedirectState();
    __DEBUG__ && logger.log("redirect", { state: state.value, redirectPath });
    if (state.value && state.value !== redirectPath) {
      if (import.meta.client) {
        state.value = "";
        window.location.assign(redirectPath);
      }
      if (import.meta.server) {
        __DEBUG__ && logger.log("differentDomains servermode", { redirectPath });
        state.value = redirectPath;
      }
    }
  } else if (redirectPath) {
    return navigateTo(redirectPath);
  }
}
export function prefixable(currentLocale, defaultLocale) {
  return (
    // strategy has no prefixes
    __I18N_STRATEGY__ !== "no_prefix" && // strategy should not prefix default locale
    !(currentLocale === defaultLocale && (__I18N_STRATEGY__ === "prefix_and_default" || __I18N_STRATEGY__ === "prefix_except_default"))
  );
}
export function createBaseUrlGetter(nuxt) {
  const logger = /* @__PURE__ */ createLogger("extendBaseUrl");
  const { baseUrl, defaultLocale } = nuxt.$config.public.i18n;
  if (isFunction(baseUrl)) {
    return () => {
      const baseUrlResult = baseUrl(nuxt);
      __DEBUG__ && logger.log("using localeLoader function -", { baseUrlResult });
      return baseUrlResult;
    };
  }
  const localeCode = isFunction(defaultLocale) ? /* @__PURE__ */ defaultLocale() : defaultLocale;
  return () => {
    if (__DIFFERENT_DOMAINS__ && localeCode) {
      const domain = nuxt._i18nGetDomainFromLocale(localeCode);
      if (domain) {
        __DEBUG__ && logger.log("using differentDomains -", { domain });
        return domain;
      }
    }
    __DEBUG__ && logger.log("using runtimeConfig -", { baseUrl });
    return baseUrl ?? "";
  };
}
export function createLocaleRouteNameGetter(defaultLocale) {
  if (__I18N_STRATEGY__ === "no_prefix" && !__DIFFERENT_DOMAINS__) {
    return (routeName) => normalizeRouteName(routeName);
  }
  const localizeRouteName = (name, locale, isDefault) => getLocalizedRouteName(name, locale, isDefault, __ROUTE_NAME_SEPARATOR__, __ROUTE_NAME_DEFAULT_SUFFIX__);
  if (__I18N_STRATEGY__ === "prefix_and_default") {
    return (name, locale) => localizeRouteName(normalizeRouteName(name), locale, locale === defaultLocale);
  }
  return (name, locale) => localizeRouteName(normalizeRouteName(name), locale, false);
}
export function createLocalizedRouteByPathResolver(router) {
  if (__I18N_STRATEGY__ === "no_prefix") {
    return (route) => route;
  }
  if (__I18N_STRATEGY__ === "prefix") {
    return (route, locale) => {
      const restPath = route.path.slice(1);
      const targetPath = route.path[0] + locale + (restPath && "/" + restPath);
      const _route = router.options.routes.find((r) => r.path === targetPath);
      if (_route == null) {
        return route;
      }
      return router.resolve(assign({}, route, _route, { path: targetPath }));
    };
  }
  return (route) => router.resolve(route);
}
function uniqueKeys(...objects) {
  const keySet = /* @__PURE__ */ new Set();
  for (const obj of objects) {
    for (const key of Object.keys(obj)) {
      keySet.add(key);
    }
  }
  return Array.from(keySet);
}
export function createNuxtI18nDev() {
  const nuxtApp = useNuxtApp();
  const composer = getComposer(nuxtApp._vueI18n);
  async function resetI18nProperties(locale) {
    const opts = await loadVueI18nOptions(vueI18nConfigs, nuxtApp);
    const messageLocales = uniqueKeys(opts.messages || {}, composer.messages.value);
    for (const k of messageLocales) {
      if (locale && k !== locale) continue;
      const current = opts.messages?.[k] || {};
      await loadAndSetLocaleMessages(k, localeLoaders, { [k]: current }, nuxtApp);
      composer.setLocaleMessage(k, current);
    }
    if (locale != null) return;
    const numberFormatLocales = uniqueKeys(opts.numberFormats || {}, composer.numberFormats.value);
    for (const k of numberFormatLocales) {
      composer.setNumberFormat(k, opts.numberFormats?.[k] || {});
    }
    const datetimeFormatsLocales = uniqueKeys(opts.datetimeFormats || {}, composer.datetimeFormats.value);
    for (const k of datetimeFormatsLocales) {
      composer.setDateTimeFormat(k, opts.datetimeFormats?.[k] || {});
    }
  }
  return { resetI18nProperties };
}
